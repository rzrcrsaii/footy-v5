#!/usr/bin/env python3
"""
Footy-Brain v5 Automated Setup Script
Handles complete local development environment setup with custom ports.
"""

import os
import sys
import subprocess
import time
import json
import shutil
from pathlib import Path
from typing import Dict, List, Tuple, Optional

# Custom port configuration to avoid conflicts
PORTS = {
    'web_dashboard': 3001,
    'api_server': 8001,
    'postgres': 5433,
    'redis': 6380,
    'grafana': 3002,
    'prometheus': 9091
}

# Color codes for output
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'

def print_status(message: str, status: str = "INFO") -> None:
    """Print colored status message."""
    color_map = {
        "INFO": Colors.BLUE,
        "SUCCESS": Colors.GREEN,
        "WARNING": Colors.YELLOW,
        "ERROR": Colors.RED,
        "STEP": Colors.PURPLE
    }
    color = color_map.get(status, Colors.WHITE)
    print(f"{color}[{status}]{Colors.END} {message}")

def run_command(command: str, cwd: Optional[str] = None, check: bool = True) -> Tuple[bool, str]:
    """Run shell command and return success status and output."""
    try:
        result = subprocess.run(
            command,
            shell=True,
            cwd=cwd,
            capture_output=True,
            text=True,
            check=check
        )
        return True, result.stdout.strip()
    except subprocess.CalledProcessError as e:
        return False, e.stderr.strip()

def check_prerequisites() -> bool:
    """Check if all required tools are installed."""
    print_status("Checking prerequisites...", "STEP")
    
    required_tools = {
        'docker': 'Docker',
        'docker-compose': 'Docker Compose',
        'python3': 'Python 3.11+',
        'node': 'Node.js 18+',
        'pnpm': 'pnpm 8+'
    }
    
    missing_tools = []
    
    for tool, name in required_tools.items():
        success, output = run_command(f"which {tool}", check=False)
        if success:
            print_status(f"‚úì {name} found", "SUCCESS")
        else:
            print_status(f"‚úó {name} not found", "ERROR")
            missing_tools.append(name)
    
    if missing_tools:
        print_status(f"Missing tools: {', '.join(missing_tools)}", "ERROR")
        print_status("Please install missing tools and run setup again.", "ERROR")
        return False
    
    return True

def create_env_file() -> bool:
    """Create .env file with custom port configuration."""
    print_status("Creating .env file with custom ports...", "STEP")
    
    env_content = f"""# Footy-Brain v5 Environment Configuration (Custom Ports)
# Generated by automated setup script

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
DATABASE_URL=postgresql://footy:footy_secure_2024@localhost:{PORTS['postgres']}/footy
DB_PASSWORD=footy_secure_2024

# =============================================================================
# REDIS CONFIGURATION
# =============================================================================
REDIS_URL=redis://localhost:{PORTS['redis']}/0

# =============================================================================
# CELERY CONFIGURATION
# =============================================================================
CELERY_BROKER_URL=redis://localhost:{PORTS['redis']}/1
CELERY_RESULT_BACKEND=redis://localhost:{PORTS['redis']}/2

# =============================================================================
# API CONFIGURATION
# =============================================================================
RAPIDAPI_KEY=your_rapidapi_key_here
JWT_SECRET=footy_jwt_secret_2024
API_HOST=0.0.0.0
API_PORT={PORTS['api_server']}

# =============================================================================
# ENVIRONMENT SETTINGS
# =============================================================================
ENVIRONMENT=development
DEBUG=true

# =============================================================================
# WORKER CONFIGURATION
# =============================================================================
LIVE_WORKER_INTERVAL=10
LIVE_WORKER_CONCURRENCY=5
FRAME_WORKER_INTERVAL=60
CELERY_WORKER_CONCURRENCY=4

# =============================================================================
# FRONTEND CONFIGURATION
# =============================================================================
NEXT_PUBLIC_API_URL=http://localhost:{PORTS['api_server']}
NEXT_PUBLIC_WS_URL=ws://localhost:{PORTS['api_server']}
NEXTAUTH_SECRET=footy_nextauth_secret_2024
NEXTAUTH_URL=http://localhost:{PORTS['web_dashboard']}

# =============================================================================
# MONITORING CONFIGURATION
# =============================================================================
GRAFANA_PASSWORD=admin
"""
    
    try:
        with open('.env', 'w') as f:
            f.write(env_content)
        print_status("‚úì .env file created successfully", "SUCCESS")
        return True
    except Exception as e:
        print_status(f"‚úó Failed to create .env file: {e}", "ERROR")
        return False

def update_docker_compose() -> bool:
    """Update docker-compose.yml with custom ports."""
    print_status("Updating docker-compose.yml with custom ports...", "STEP")
    
    try:
        # Read original docker-compose.yml
        with open('docker-compose.yml', 'r') as f:
            content = f.read()
        
        # Create backup
        shutil.copy('docker-compose.yml', 'docker-compose.yml.backup')
        
        # Replace ports
        replacements = {
            '"5432:5432"': f'"{PORTS["postgres"]}:5432"',
            '"6379:6379"': f'"{PORTS["redis"]}:6379"',
            '"8000:8000"': f'"{PORTS["api_server"]}:8000"',
            '"3000:3000"': f'"{PORTS["web_dashboard"]}:3000"',
            '"3001:3000"': f'"{PORTS["grafana"]}:3000"',
            '"9090:9090"': f'"{PORTS["prometheus"]}:9090"'
        }
        
        for old, new in replacements.items():
            content = content.replace(old, new)
        
        # Write updated content
        with open('docker-compose.yml', 'w') as f:
            f.write(content)
        
        print_status("‚úì docker-compose.yml updated successfully", "SUCCESS")
        return True
    except Exception as e:
        print_status(f"‚úó Failed to update docker-compose.yml: {e}", "ERROR")
        return False

def update_next_config() -> bool:
    """Update Next.js configuration with custom ports."""
    print_status("Updating Next.js configuration...", "STEP")
    
    try:
        config_path = Path('apps/web-dashboard/next.config.js')
        if not config_path.exists():
            print_status("‚úó next.config.js not found", "ERROR")
            return False
        
        with open(config_path, 'r') as f:
            content = f.read()
        
        # Replace API URLs
        content = content.replace(
            "process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'",
            f"process.env.NEXT_PUBLIC_API_URL || 'http://localhost:{PORTS['api_server']}'"
        )
        content = content.replace(
            "process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8000'",
            f"process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:{PORTS['api_server']}'"
        )
        
        with open(config_path, 'w') as f:
            f.write(content)
        
        print_status("‚úì Next.js configuration updated", "SUCCESS")
        return True
    except Exception as e:
        print_status(f"‚úó Failed to update Next.js config: {e}", "ERROR")
        return False

def install_dependencies() -> bool:
    """Install Python and Node.js dependencies."""
    print_status("Installing dependencies...", "STEP")

    # Check if Poetry is available, otherwise use pip
    poetry_available, _ = run_command("poetry --version", check=False)

    if poetry_available:
        print_status("Installing Python dependencies with Poetry...", "INFO")
        success, output = run_command("poetry install")
        if not success:
            print_status(f"‚úó Poetry install failed: {output}", "ERROR")
            return False
    else:
        print_status("Poetry not found, installing with pip...", "INFO")
        # Create virtual environment
        success, output = run_command("python -m venv .venv")
        if not success:
            print_status(f"‚úó Failed to create virtual environment: {output}", "ERROR")
            return False

        # Activate virtual environment and install dependencies
        if os.name == 'nt':  # Windows
            activate_cmd = ".venv\\Scripts\\activate && "
        else:  # Unix/Linux/Mac
            activate_cmd = "source .venv/bin/activate && "

        # Install basic dependencies
        deps = [
            "fastapi[all]",
            "uvicorn[standard]",
            "sqlmodel",
            "asyncpg",
            "redis",
            "celery",
            "httpx",
            "pydantic",
            "python-multipart",
            "python-jose[cryptography]",
            "passlib[bcrypt]",
            "pytest",
            "pytest-asyncio",
            "ruff",
            "mypy"
        ]

        for dep in deps:
            success, output = run_command(f"{activate_cmd}pip install {dep}")
            if not success:
                print_status(f"‚úó Failed to install {dep}: {output}", "ERROR")
                return False

    print_status("‚úì Python dependencies installed", "SUCCESS")

    # Install Node.js dependencies
    print_status("Installing Node.js dependencies with pnpm...", "INFO")
    success, output = run_command("pnpm install", cwd="apps/web-dashboard")
    if not success:
        print_status(f"‚úó pnpm install failed: {output}", "ERROR")
        return False
    print_status("‚úì Node.js dependencies installed", "SUCCESS")

    return True

def start_infrastructure() -> bool:
    """Start PostgreSQL and Redis containers."""
    print_status("Starting infrastructure services...", "STEP")
    
    # Stop any existing containers
    run_command("docker-compose down", check=False)
    
    # Start PostgreSQL and Redis
    success, output = run_command("docker-compose up -d pg redis")
    if not success:
        print_status(f"‚úó Failed to start infrastructure: {output}", "ERROR")
        return False
    
    # Wait for services to be ready
    print_status("Waiting for services to be ready...", "INFO")
    time.sleep(10)
    
    # Check PostgreSQL
    for attempt in range(30):
        success, _ = run_command(
            f"docker exec footy-brain-db pg_isready -U footy -d footy -p 5432",
            check=False
        )
        if success:
            break
        time.sleep(2)
    else:
        print_status("‚úó PostgreSQL failed to start", "ERROR")
        return False
    
    print_status("‚úì Infrastructure services started", "SUCCESS")
    return True

def initialize_database() -> bool:
    """Initialize database with DDL scripts."""
    print_status("Initializing database...", "STEP")
    
    # Database should be initialized automatically by docker-entrypoint-initdb.d
    # But let's verify it's working
    success, output = run_command(
        f"docker exec footy-brain-db psql -U footy -d footy -c '\\dt'",
        check=False
    )
    
    if success and "fixture" in output:
        print_status("‚úì Database initialized successfully", "SUCCESS")
        return True
    else:
        print_status("‚ö† Database may need manual initialization", "WARNING")
        return True  # Continue anyway

def start_api_server() -> bool:
    """Start the FastAPI server."""
    print_status("Starting API server...", "STEP")
    
    # Start API server in background
    success, output = run_command(
        f"nohup python apps/api-server/main.py > api-server.log 2>&1 &",
        check=False
    )
    
    # Wait for API server to start
    print_status("Waiting for API server to start...", "INFO")
    for attempt in range(30):
        success, _ = run_command(
            f"curl -f http://localhost:{PORTS['api_server']}/health",
            check=False
        )
        if success:
            print_status("‚úì API server started successfully", "SUCCESS")
            return True
        time.sleep(2)
    
    print_status("‚úó API server failed to start", "ERROR")
    return False

def start_web_dashboard() -> bool:
    """Start the Next.js web dashboard."""
    print_status("Starting web dashboard...", "STEP")
    
    # Start web dashboard in background
    success, output = run_command(
        "nohup pnpm dev > web-dashboard.log 2>&1 &",
        cwd="apps/web-dashboard",
        check=False
    )
    
    # Wait for web dashboard to start
    print_status("Waiting for web dashboard to start...", "INFO")
    for attempt in range(60):  # Next.js takes longer to start
        success, _ = run_command(
            f"curl -f http://localhost:{PORTS['web_dashboard']}/api/health",
            check=False
        )
        if success:
            print_status("‚úì Web dashboard started successfully", "SUCCESS")
            return True
        time.sleep(3)
    
    print_status("‚úó Web dashboard failed to start", "ERROR")
    return False

def verify_services() -> Dict[str, bool]:
    """Verify all services are running and healthy."""
    print_status("Verifying all services...", "STEP")
    
    services = {
        f"PostgreSQL (:{PORTS['postgres']})": f"docker exec footy-brain-db pg_isready -U footy -d footy",
        f"Redis (:{PORTS['redis']})": f"docker exec footy-brain-redis redis-cli ping",
        f"API Server (:{PORTS['api_server']})": f"curl -f http://localhost:{PORTS['api_server']}/health",
        f"Web Dashboard (:{PORTS['web_dashboard']})": f"curl -f http://localhost:{PORTS['web_dashboard']}/api/health"
    }
    
    results = {}
    for service, command in services.items():
        success, _ = run_command(command, check=False)
        results[service] = success
        status = "SUCCESS" if success else "ERROR"
        symbol = "‚úì" if success else "‚úó"
        print_status(f"{symbol} {service}", status)
    
    return results

def print_final_summary(service_results: Dict[str, bool]) -> None:
    """Print final setup summary with service URLs."""
    print("\n" + "="*80)
    print_status("üéâ FOOTY-BRAIN V5 SETUP COMPLETE!", "SUCCESS")
    print("="*80)
    
    print(f"\n{Colors.BOLD}üìä Service Status:{Colors.END}")
    for service, status in service_results.items():
        symbol = "‚úÖ" if status else "‚ùå"
        print(f"  {symbol} {service}")
    
    print(f"\n{Colors.BOLD}üåê Service URLs (Custom Ports):{Colors.END}")
    urls = [
        f"üéØ Web Dashboard:    http://localhost:{PORTS['web_dashboard']}",
        f"üîß API Server:       http://localhost:{PORTS['api_server']}",
        f"üìö API Docs:         http://localhost:{PORTS['api_server']}/docs",
        f"üíæ PostgreSQL:       localhost:{PORTS['postgres']} (footy/footy_secure_2024)",
        f"üî¥ Redis:            localhost:{PORTS['redis']}",
    ]
    
    for url in urls:
        print(f"  {url}")
    
    print(f"\n{Colors.BOLD}üöÄ Quick Commands:{Colors.END}")
    commands = [
        "# Check service health",
        f"curl http://localhost:{PORTS['api_server']}/health",
        f"curl http://localhost:{PORTS['web_dashboard']}/api/health",
        "",
        "# View logs",
        "tail -f api-server.log",
        "tail -f web-dashboard.log",
        "",
        "# Stop services",
        "docker-compose down",
        "pkill -f 'python apps/api-server/main.py'",
        "pkill -f 'pnpm dev'"
    ]
    
    for cmd in commands:
        if cmd.startswith("#"):
            print(f"  {Colors.CYAN}{cmd}{Colors.END}")
        elif cmd == "":
            print()
        else:
            print(f"  {cmd}")
    
    print(f"\n{Colors.BOLD}‚ö†Ô∏è  Important Notes:{Colors.END}")
    notes = [
        "‚Ä¢ Add your RapidAPI key to .env file for live data",
        "‚Ä¢ Services are running on custom ports to avoid conflicts",
        "‚Ä¢ Original docker-compose.yml backed up as docker-compose.yml.backup",
        "‚Ä¢ Use 'docker-compose down' to stop infrastructure services"
    ]
    
    for note in notes:
        print(f"  {note}")
    
    print("\n" + "="*80)

def cleanup_on_failure() -> None:
    """Cleanup resources if setup fails."""
    print_status("Cleaning up due to setup failure...", "WARNING")
    
    # Stop any started services
    run_command("docker-compose down", check=False)
    run_command("pkill -f 'python apps/api-server/main.py'", check=False)
    run_command("pkill -f 'pnpm dev'", check=False)
    
    # Restore backup if exists
    if Path('docker-compose.yml.backup').exists():
        shutil.move('docker-compose.yml.backup', 'docker-compose.yml')
        print_status("‚úì Restored original docker-compose.yml", "INFO")

def main() -> None:
    """Main setup function."""
    print(f"{Colors.BOLD}{Colors.BLUE}")
    print("üèà‚ö° FOOTY-BRAIN V5 AUTOMATED SETUP")
    print("Real-time Football Data Platform")
    print("="*50)
    print(f"{Colors.END}")
    
    try:
        # Step 1: Check prerequisites
        if not check_prerequisites():
            sys.exit(1)
        
        # Step 2: Create environment file
        if not create_env_file():
            cleanup_on_failure()
            sys.exit(1)
        
        # Step 3: Update configuration files
        if not update_docker_compose():
            cleanup_on_failure()
            sys.exit(1)
        
        if not update_next_config():
            cleanup_on_failure()
            sys.exit(1)
        
        # Step 4: Install dependencies
        if not install_dependencies():
            cleanup_on_failure()
            sys.exit(1)
        
        # Step 5: Start infrastructure
        if not start_infrastructure():
            cleanup_on_failure()
            sys.exit(1)
        
        # Step 6: Initialize database
        if not initialize_database():
            cleanup_on_failure()
            sys.exit(1)
        
        # Step 7: Start application services
        if not start_api_server():
            cleanup_on_failure()
            sys.exit(1)
        
        if not start_web_dashboard():
            cleanup_on_failure()
            sys.exit(1)
        
        # Step 8: Verify all services
        service_results = verify_services()
        
        # Step 9: Print final summary
        print_final_summary(service_results)
        
        # Check if any service failed
        if not all(service_results.values()):
            print_status("‚ö†Ô∏è  Some services failed to start. Check logs for details.", "WARNING")
            sys.exit(1)
        
    except KeyboardInterrupt:
        print_status("\nüõë Setup interrupted by user", "WARNING")
        cleanup_on_failure()
        sys.exit(1)
    except Exception as e:
        print_status(f"üí• Unexpected error: {e}", "ERROR")
        cleanup_on_failure()
        sys.exit(1)

if __name__ == "__main__":
    main()
